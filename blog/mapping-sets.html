<!DOCTYPE html>
<html data-bulma-theme="light">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" href="../img/favicon.ico" sizes="32x32">
  <link rel="icon" href="../img/favicon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="../img/apple-touch-icon.png">

  <script src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/js/all.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/fontawesome.min.css"
    rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">

  <link rel="stylesheet" href="../main.css">
  <link rel="stylesheet" href="../css/code.css">
  <link rel="stylesheet" href="../search/docs.css">
  <script src="../main.js"></script>

  <title>How can we map a Set?</title>
</head>

<body>
  <nav class="bulma-navbar" role="navigation" aria-label="main navigation">
  <div class="bulma-navbar-brand">
    <a class="bulma-navbar-item" href="../">
      <img src="../img/logo.svg" />
    </a>

    <a role="button" class="bulma-navbar-burger" aria-label="menu" aria-expanded="false" data-target="navMenu"
      onClick="handleBurgerClick(this)">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>
  <div class="bulma-navbar-menu" id="navMenu">
    <div class="bulma-navbar-start">

    </div>
    <div class="bulma-navbar-end">
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-rounded bulma-is-link">Get Started</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-white">Learn</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-white">Community</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-white">Foundation</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-white" href="index.html">Blog</a>
      </div>
      <div class="bulma-navbar-item">
        <a id="search-top-bar" class="bulma-button bulma-is-white" aria-label="Search" onclick="showSearchModal()">
          <span class="bulma-icon bulma-is-small">
            <i class="fas fa-magnifying-glass"></i>
          </span>
        </a>
      </div>
    </div>
  </div>
</nav>

<!-- Search Modal -->
<div id="search-modal" class="bulma-modal bulma-is-justify-content-flex-start bulma-pt-6 bulma-pb-6">
  <div class="bulma-modal-background bulma-is-align-items-flex-start" onclick="hideSearchModal()"></div>
  <div class="bulma-modal-card">
    <header class="bulma-modal-card-head">
      <p class="bulma-control bulma-has-icons-left bulma-is-flex-grow-1">
        <input id="search-input" class="bulma-input bulma-is-medium" type="search" autocomplete="off" oninput="onSearchInput(event)">
        <span class="bulma-icon bulma-is-left">
          <i class="fas fa-magnifying-glass"></i>
        </span>
      </p>
    </header>
    <section id="search-results" class="bulma-modal-card-body">
    </section>
    <footer class="bulma-modal-card-foot bulma-is-justify-content-space-between">
      <span class="bulma-has-text-grey bulma-is-size-7">
        <kbd class="bulma-tag">/</kbd> to open search &nbsp;
        <kbd class="bulma-tag">Esc</kbd> to close
      </span>
    </footer>
  </div>
</div>

  <main>
    
<section class="bulma-hero bulma-is-primary bulma-is-bold">
  <div class="bulma-hero-body bulma-container bulma-is-max-desktop">
    <p class="bulma-title">How can we map a Set?</p>
    <p class="blog-post-byline bulma-subtitle">
      by
      
        Brian McKenna<span class="delimiter">,</span><span class="last-delimiter"> &</span>
      
      on June 22, 2014
    </p>
     
      <span class="bulma-tag">technical</span>
     
  </div>
</section>
<div class="bulma-section bulma-container bulma-is-max-desktop">
  <div class="blog-post bulma-content">
    <h1 id="how-can-we-map-a-set" class="title">How can we map a Set?</h1>
    <p>Scalaz used to have a <code>scalaz.Functor</code> for <code>scala.collection.Set</code> but
    it was <a href="https://github.com/scalaz/scalaz/pull/276">eventually removed</a>
    because it relied on
    <a href="http://www.scala-lang.org/api/2.10.3/index.html#scala.Any">Any&#39;s == method</a>. You
    can read more about why <code>Functor[Set]</code> is a bad idea at
    <a href="http://failex.blogspot.jp/2013/06/fake-theorems-for-free.html">Fake Theorems for Free</a>.</p>
    <p>If <code>Set</code> had been truly parametric, we wouldn&#39;t have been able to
    define a <code>Functor</code> in the first place. Luckily, a truly parametric Set
    has recently been added to Scalaz as <code>scalaz.ISet</code>, with preliminary
    benchmarks also showing some nice performance improvements. I highly
    recommend using <code>ISet</code> whenever you can!</p>
    <p>Now we can see the problem more clearly; the type of <code>map</code> on <code>ISet</code>
    is too restrictive to be used inside of a <code>Functor</code> because of the
    <code>scalaz.Order</code> constraint:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">map</span><span>[</span><span class="type-name">B</span><span>: </span><span class="type-name">Order</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>): </span><span class="type-name">ISet</span><span>[</span><span class="type-name">B</span><span>]</span></code></pre>
    <p>And it might seem like we&#39;ve lost something useful by not having a
    <code>Functor</code> available. For example, we can&#39;t write the following:</p>
    <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">nes</span><span> = </span><span class="type-name">OneAnd</span><span>(</span><span class="string-literal">&quot;2014-05-01&quot;</span><span>, </span><span class="type-name">ISet</span><span>.</span><span class="identifier">fromList</span><span>(</span><span class="string-literal">&quot;2014-06-01&quot;</span><span> :: </span><span class="string-literal">&quot;2014-06-22&quot;</span><span> :: </span><span class="type-name">Nil</span><span>)) </span><span class="comment">// a non-empty Set
</span><span class="keyword">val</span><span> </span><span class="type-name">OneAnd</span><span>(</span><span class="identifier">h</span><span>, </span><span class="identifier">t</span><span>) = </span><span class="identifier">nes</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">parseDate</span><span>)</span></code></pre>
    <p>Which is because the <code>map</code> function on <code>scalaz.OneAnd</code> requires a
    <code>scalaz.Functor</code> for the <code>F[_]</code> type parameter, which is <code>ISet</code> in the
    above example.</p>
    <p>But we have a solution! It&#39;s called
    <a href="http://docs.typelevel.org/api/scalaz/nightly/#scalaz.Coyoneda">Coyoneda</a>
    (also known as the Free Functor) and it&#39;ll hopefully be able to
    demonstrate why not having <code>Functor[ISet]</code> available has no
    fundamental, practical consequences.</p>
    <p>Coyoneda
    <a href="http://blog.higher-order.com/blog/2013/11/01/free-and-yoneda/">can be defined in Scala</a>
    like so:</p>
    <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">Coyoneda</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>], </span><span class="type-name">A</span><span>] {
  </span><span class="keyword">type</span><span> </span><span class="type-name">I</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">k</span><span>: </span><span class="type-name">I</span><span> =&gt; </span><span class="type-name">A</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">fi</span><span>: </span><span class="type-name">F</span><span>[</span><span class="type-name">I</span><span>]
}</span></code></pre>
    <p>There are just three parts to it:</p>
    <ol class="arabic">
      <li><code>I</code> - an existential type</li>
      <li><code>k</code> - a mapping from <code>I</code> to <code>A</code></li>
      <li><code>fi</code> - a value of <code>F[I]</code></li>
    </ol>
    <p>We can create a couple of functions to help with constructing a
    Coyoneda value:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>], </span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">fa</span><span>: </span><span class="type-name">F</span><span>[</span><span class="type-name">A</span><span>])(</span><span class="identifier">_k</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>): </span><span class="type-name">Coyoneda</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">B</span><span>] { </span><span class="keyword">type</span><span> </span><span class="type-name">I</span><span> = </span><span class="type-name">A</span><span> } =
  </span><span class="keyword">new</span><span> </span><span class="type-name">Coyoneda</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">B</span><span>] {
    </span><span class="keyword">type</span><span> </span><span class="type-name">I</span><span> = </span><span class="type-name">A</span><span>
    </span><span class="keyword">val</span><span> </span><span class="identifier">k</span><span> = </span><span class="identifier">_k</span><span>
    </span><span class="keyword">val</span><span> </span><span class="identifier">fi</span><span> = </span><span class="identifier">fa</span><span>
  }

</span><span class="keyword">def</span><span> </span><span class="declaration-name">lift</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>], </span><span class="type-name">A</span><span>](</span><span class="identifier">fa</span><span>: </span><span class="type-name">F</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Coyoneda</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">A</span><span>] = </span><span class="type-name">Coyoneda</span><span>(</span><span class="identifier">fa</span><span>)(</span><span class="identifier">identity</span><span>[</span><span class="type-name">A</span><span>])</span></code></pre>
    <p>The constructors allow any type constructor to become a Coyoneda value:</p>
    <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">s</span><span>: </span><span class="type-name">Coyoneda</span><span>[</span><span class="type-name">ISet</span><span>, </span><span class="type-name">Int</span><span>] = </span><span class="type-name">Coyoneda</span><span>.</span><span class="identifier">lift</span><span>(</span><span class="type-name">ISet</span><span>.</span><span class="identifier">fromList</span><span>(</span><span class="number-literal">1</span><span> :: </span><span class="number-literal">2</span><span> :: </span><span class="number-literal">3</span><span> :: </span><span class="type-name">Nil</span><span>))</span></code></pre>
    <p>Now here&#39;s the special part; we can define a <code>Functor</code> for all
    Coyoneda values:</p>
    <pre><code class="nohighlight"><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">coyonedaFunctor</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]]: </span><span class="type-name">Functor</span><span>[({</span><span class="keyword">type</span><span> λ[α] = </span><span class="type-name">Coyoneda</span><span>[</span><span class="type-name">F</span><span>, α]})#λ] =
  </span><span class="keyword">new</span><span> </span><span class="type-name">Functor</span><span>[({</span><span class="keyword">type</span><span> λ[α] = </span><span class="type-name">Coyoneda</span><span>[</span><span class="type-name">F</span><span>,α]})#λ] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">map</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">ya</span><span>: </span><span class="type-name">Coyoneda</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">A</span><span>])(</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>) = </span><span class="type-name">Coyoneda</span><span>(</span><span class="identifier">ya</span><span>.</span><span class="identifier">fi</span><span>)(</span><span class="identifier">f</span><span> </span><span class="identifier">compose</span><span> </span><span class="identifier">ya</span><span>.</span><span class="identifier">k</span><span>)
  }</span></code></pre>
    <p>What&#39;s interesting is that the <code>F[_]</code> type does <em>not</em> have to have a
    <code>Functor</code> defined for the Coyoneda to be mapped!</p>
    <p>Let&#39;s use this to try out our original example. We&#39;ll define a type
    alias to make things a bit cleaner:</p>
    <pre><code class="nohighlight"><span class="keyword">type</span><span> </span><span class="type-name">ISetF</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="type-name">Coyoneda</span><span>[</span><span class="type-name">ISet</span><span>, </span><span class="type-name">A</span><span>]</span></code></pre>
    <p>And we can use this new type instead of a plain <code>ISet</code>:</p>
    <pre><code class="nohighlight"><span class="comment">// Scala has a really hard time with inference here, so we have to help it out.
</span><span class="keyword">val</span><span> </span><span class="identifier">functor</span><span> = </span><span class="type-name">OneAnd</span><span>.</span><span class="identifier">oneAndFunctor</span><span>[</span><span class="type-name">ISetF</span><span>](</span><span class="type-name">Coyoneda</span><span>.</span><span class="identifier">coyonedaFunctor</span><span>[</span><span class="type-name">ISet</span><span>])
</span><span class="keyword">import</span><span> </span><span class="identifier">functor</span><span>.</span><span class="identifier">functorSyntax</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">nes</span><span> = </span><span class="type-name">OneAnd</span><span>[</span><span class="type-name">ISetF</span><span>, </span><span class="type-name">String</span><span>](</span><span class="string-literal">&quot;2014-05-01&quot;</span><span>, </span><span class="type-name">Coyoneda</span><span>.</span><span class="identifier">lift</span><span>(</span><span class="type-name">ISet</span><span>.</span><span class="identifier">fromList</span><span>(</span><span class="string-literal">&quot;2014-06-01&quot;</span><span> :: </span><span class="string-literal">&quot;2014-06-22&quot;</span><span> :: </span><span class="type-name">Nil</span><span>)))
</span><span class="keyword">val</span><span> </span><span class="type-name">OneAnd</span><span>(</span><span class="identifier">h</span><span>, </span><span class="identifier">t</span><span>) = </span><span class="identifier">nes</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">parseDate</span><span>)</span></code></pre>
    <p>So we&#39;ve been able to map the Coyoneda! But how do we do something
    useful with it?</p>
    <p>We couldn&#39;t define a <code>Functor</code> because it needs <code>scalaz.Order</code> on the
    output type, but we can use the <code>map</code> method directly on <code>ISet</code>. We
    can use that function by running the Coyoneda like so:</p>
    <pre><code class="nohighlight"><span class="comment">// Converts ISetF back to an ISet, using ISet#map with the Order constraint
</span><span class="keyword">val</span><span> </span><span class="identifier">s</span><span> = </span><span class="identifier">t</span><span>.</span><span class="identifier">fi</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">t</span><span>.</span><span class="identifier">k</span><span>).</span><span class="identifier">insert</span><span>(</span><span class="identifier">h</span><span>)</span></code></pre>
    <p>And we&#39;re done!</p>
    <p>We&#39;ve been able to use Coyoneda to treat an <code>ISet</code> as a <code>Functor</code>,
    even though its map function is too constrained to have one defined
    directly. This same technique applies to <code>scala.collection.Set</code> and
    any other type-constructor which would otherwise require a
    <a href="http://okmij.org/ftp/Haskell/types.html#restricted-datatypes">restricted <code>Functor</code></a>. I
    hope this has demonstrated that <code>Functor[Set]</code> not existing has no
    practical consequences, other than scalac not being as good at
    type-inference.</p>
  </div>
</div>
<div class="bulma-section bulma-container bulma-is-max-desktop">
  <div class="bulma-columns">
    
    <div class="bulma-column">
      <article class="bulma-media">
        
        <figure class="bulma-media-left">
          <p class="bulma-image bulma-is-64x64">
            <img class="bulma-is-rounded" src="https://github.com/puffnfresh.png" />
          </p>
        </figure>
        
        <div class="bulma-media-content">
          <div class="bulma-content">
            <p>
              <strong>Brian McKenna</strong>
              
            </p>
          </div>
          <nav class="bulma-level">
            <div class="bulma-level-left bulma-is-flex-direction-row">
              
              <a class="bulma-level-item" href="http://github.com/puffnfresh">
                <span class="bulma-icon bulma-is-small"><i class="fab fa-github"></i></span>
              </a>
              
              
              
              
            </div>
          </nav>
        </div>
      </article>
    </div>
    
  </div>
</div>


  </main>
  <footer class="bulma-footer">
  <div class="bulma-columns">
    <div class="bulma-column">
      Copyright <i class="fab fa-creative-commons"></i> Typelevel Foundation and contributors.
    </div>
    <div class="bulma-column">
      <ul>
        <li><a href="../projects/">Project Index</a></li>
        <li><a href="#">Documentation</a></li>
        <li><a href="#">Contributing</a></li>
      </ul>
    </div>
    <div class="bulma-column">
      <ul>
        <li><a href="../code-of-conduct/">Code of Conduct</a></li>
        <li><a href="../security.html">Security Policy</a></li>
        <li><a href="#">Colophon</a></li>
      </ul>
    </div>
  </div>
  <div class="bulma-has-text-centered">
    <div>Find us on ...</div>
    <div>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://github.com/typelevel">
        <i class="fab fa-github fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://discord.gg/pey2hnSQGS">
        <i class="fab fa-discord fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://bsky.app/profile/typelevel.org">
        <i class="fab fa-bluesky fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://fosstodon.org/@typelevel">
        <i class="fab fa-mastodon fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://www.youtube.com/@typelevel">
        <i class="fab fa-youtube fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current"
        href="https://linkedin.com/company/typelevel-foundation">
        <i class="fab fa-linkedin fa-2x"></i>
      </a>
    </div>
  </div>
</footer>

</body>

</html>

