<!DOCTYPE html>
<html data-bulma-theme="light">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" href="../img/favicon.ico" sizes="32x32">
  <link rel="icon" href="../img/favicon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="../img/apple-touch-icon.png">

  <script src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/js/all.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/fontawesome.min.css"
    rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.28/dist/katex.min.css" integrity="sha384-Wsr4Nh3yrvMf2KCebJchRJoVo1gTU6kcP05uRSh5NV3sj9+a8IomuJoQzf3sMq4T" crossorigin="anonymous">

  <link rel="stylesheet" href="../main.css">
  <link rel="stylesheet" href="../css/code.css">
  <link rel="stylesheet" href="../search/docs.css">
  <script src="../main.js"></script>

  <title>Why is ADT pattern matching allowed?</title>
</head>

<body class="bulma-is-flex bulma-is-flex-direction-column">
  <nav class="bulma-navbar" role="navigation" aria-label="main navigation">
  <div class="bulma-navbar-brand">
    <a class="bulma-navbar-item" href="../">
      <img src="../img/logo.svg" />
    </a>

    <a role="button" class="bulma-navbar-burger" aria-label="menu" aria-expanded="false" data-target="navMenu"
      onClick="handleBurgerClick(this)">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>
  <div class="bulma-navbar-menu" id="navMenu">
    <div class="bulma-navbar-start">

    </div>
    <div class="bulma-navbar-end">
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-rounded bulma-is-primary bulma-has-text-light">Get Started</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text">Learn</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text">Community</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text" href="../foundation/">Foundation</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text" href="index.html">Blog</a></div>
      <div class="bulma-navbar-item">
        <a id="search-top-bar" class="bulma-button bulma-is-text" aria-label="Search" onclick="showSearchModal()">
          <span class="bulma-icon bulma-is-small">
            <i class="fas fa-magnifying-glass"></i>
          </span>
        </a>
      </div>
    </div>
  </div>
</nav>

<!-- Search Modal -->
<div id="search-modal" class="bulma-modal bulma-is-justify-content-flex-start bulma-pt-6 bulma-pb-6">
  <div class="bulma-modal-background bulma-is-align-items-flex-start" onclick="hideSearchModal()"></div>
  <div class="bulma-modal-card">
    <header class="bulma-modal-card-head">
      <p class="bulma-control bulma-has-icons-left bulma-is-flex-grow-1">
        <input id="search-input" class="bulma-input bulma-is-medium bulma-is-primary" type="search" autocomplete="off" oninput="onSearchInput(event)">
        <span class="bulma-icon bulma-is-left bulma-has-text-primary">
          <i class="fas fa-magnifying-glass"></i>
        </span>
      </p>
    </header>
    <section id="search-results" class="bulma-modal-card-body">
    </section>
    <footer class="bulma-modal-card-foot bulma-is-justify-content-space-between">
      <span class="bulma-has-text-grey bulma-is-size-7">
        <kbd class="bulma-tag">/</kbd> to open search &nbsp;
        <kbd class="bulma-tag">Esc</kbd> to close
      </span>
    </footer>
  </div>
</div>

  <main class="bulma-is-flex-grow-1">
    
<section class="bulma-hero bulma-is-primary bulma-is-bold">
  <div class="bulma-hero-body bulma-container bulma-is-max-desktop">
    <p class="bulma-title bulma-has-text-light">Why is ADT pattern matching allowed?</p>
    <p class="blog-post-byline bulma-has-text-light bulma-subtitle">
      by
      
        Stephen Compall<span class="delimiter">,</span><span class="last-delimiter"> &</span>
      
      on November 10, 2014
    </p>
     
      <span class="bulma-tag">technical</span>
     
  </div>
</section>
<div class="bulma-section bulma-container bulma-is-max-desktop">
  <div class="blog-post bulma-content">
    <h1 id="why-is-adt-pattern-matching-allowed" class="title">Why is ADT pattern matching allowed?</h1>
    <p>One of the rules of
    <a href="https://dl.dropboxusercontent.com/u/7810909/talks/parametricity/4985cb8e6d8d9a24e32d98204526c8e3b9319e33/parametricity.pdf">the Scalazzi Safe Scala Subset</a>
    is “no type casing”; in other words, testing the type via
    <code>isInstanceOf</code> or type patterns isn’t allowed.  It’s one of the most
    important rules therein for preservation of free theorems.  Common
    functional programming practice in Scala <em>seems</em> to violate this rule
    in a subtle way.  However, as we will see, that practice carves out a
    very specific exception to this rule that, morally, isn’t an exception
    at all, carrying convenient advantages and none of the drawbacks.</p>
    
    <h2 id="why-forbid-type-tests" class="section"><a class="anchor-link" href="#why-forbid-type-tests"><code class="fas fa-link fa-sm"></code></a>Why forbid type tests?</h2>
    <p>With the “no type tests” rule, we forbid writing functions like this:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">revmaybe</span><span>[</span><span class="type-name">T</span><span>](</span><span class="identifier">xs</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">T</span><span>]): </span><span class="type-name">List</span><span>[</span><span class="type-name">T</span><span>] = {
  </span><span class="keyword">val</span><span> </span><span class="identifier">allInts</span><span> = </span><span class="identifier">xs</span><span>.</span><span class="identifier">forall</span><span>{</span><span class="keyword">case</span><span> </span><span class="identifier">_</span><span>:</span><span class="type-name">Int</span><span> =&gt; </span><span class="boolean-literal">true</span><span>
                          </span><span class="keyword">case</span><span> </span><span class="identifier">_</span><span> =&gt; </span><span class="boolean-literal">false</span><span>}
  </span><span class="keyword">if</span><span> (</span><span class="identifier">allInts</span><span>) </span><span class="identifier">xs</span><span>.</span><span class="identifier">reverse</span><span> </span><span class="keyword">else</span><span> </span><span class="identifier">xs</span><span>
}</span></code></pre>
    <p>Which violates the
    <a href="http://failex.blogspot.com/2013/06/fake-theorems-for-free.html">free theorem</a>
    of <code>revmaybe</code>’s type <code>revmaybe(xs map f) = revmaybe(xs) map f</code>, as
    follows.</p>
    <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">xs</span><span> = </span><span class="type-name">List</span><span>(</span><span class="number-literal">1</span><span>, </span><span class="number-literal">2</span><span>, </span><span class="number-literal">3</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">f</span><span>(</span><span class="identifier">i</span><span>:</span><span class="type-name">Int</span><span>) = </span><span class="type-name">Some</span><span>(</span><span class="identifier">i</span><span>)

</span><span class="identifier">scala</span><span>&gt; </span><span class="identifier">revmaybe</span><span>(</span><span class="identifier">xs</span><span> </span><span class="identifier">map</span><span> </span><span class="identifier">f</span><span>)
</span><span class="identifier">res2</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Some</span><span>[</span><span class="type-name">Int</span><span>]] = </span><span class="type-name">List</span><span>(</span><span class="type-name">Some</span><span>(</span><span class="number-literal">1</span><span>), </span><span class="type-name">Some</span><span>(</span><span class="number-literal">2</span><span>), </span><span class="type-name">Some</span><span>(</span><span class="number-literal">3</span><span>))

</span><span class="identifier">scala</span><span>&gt; </span><span class="identifier">revmaybe</span><span>(</span><span class="identifier">xs</span><span>) </span><span class="identifier">map</span><span> </span><span class="identifier">f</span><span>
</span><span class="identifier">res3</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Some</span><span>[</span><span class="type-name">Int</span><span>]] = </span><span class="type-name">List</span><span>(</span><span class="type-name">Some</span><span>(</span><span class="number-literal">3</span><span>), </span><span class="type-name">Some</span><span>(</span><span class="number-literal">2</span><span>), </span><span class="type-name">Some</span><span>(</span><span class="number-literal">1</span><span>))</span></code></pre>
    
    <h2 id="adts-are-ok-to-go" class="section"><a class="anchor-link" href="#adts-are-ok-to-go"><code class="fas fa-link fa-sm"></code></a>ADTs are OK to go</h2>
    <p>On the other hand, the Scalazzi rules are totally cool with pattern
    matching to separate the parts of
    <a href="https://www.haskell.org/haskellwiki/Algebraic_data_type">ADTs</a>.  For
    example, this is completely fine.</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">headOption</span><span>[</span><span class="type-name">T</span><span>](</span><span class="identifier">xs</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">T</span><span>]): </span><span class="type-name">Option</span><span>[</span><span class="type-name">T</span><span>] = </span><span class="identifier">xs</span><span> </span><span class="keyword">match</span><span> {
  </span><span class="keyword">case</span><span> </span><span class="identifier">x</span><span> :: </span><span class="identifier">_</span><span> =&gt; </span><span class="type-name">Some</span><span>(</span><span class="identifier">x</span><span>)
  </span><span class="keyword">case</span><span> </span><span class="identifier">_</span><span> =&gt; </span><span class="type-name">None</span><span>
}</span></code></pre>
    <p>Even more exotic matches, where we bring type information forward into
    runtime, are acceptable, as long as they’re in the context of ADTs.</p>
    <pre><code class="nohighlight"><span class="keyword">sealed</span><span> </span><span class="keyword">abstract</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Expr</span><span>[</span><span class="type-name">T</span><span>]
</span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">AddExpr</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>[</span><span class="type-name">Int</span><span>]

</span><span class="keyword">def</span><span> </span><span class="declaration-name">eval</span><span>[</span><span class="type-name">T</span><span>](</span><span class="identifier">ex</span><span>: </span><span class="type-name">Expr</span><span>[</span><span class="type-name">T</span><span>]): </span><span class="type-name">T</span><span> = </span><span class="identifier">ex</span><span> </span><span class="keyword">match</span><span> {
  </span><span class="keyword">case</span><span> </span><span class="type-name">AddExpr</span><span>(</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>) =&gt; </span><span class="identifier">x</span><span> + </span><span class="identifier">y</span><span>
}</span></code></pre>
    
    <h2 id="adts-use-type-tests" class="section"><a class="anchor-link" href="#adts-use-type-tests"><code class="fas fa-link fa-sm"></code></a>ADTs use type tests</h2>
    <p>Let’s look at the compiled code of the <code>eval</code> body, specifically, the
    <code>case</code> line.</p>
    <pre><code class="nasm">         2: aload_2       
         3: instanceof    #60                 // class adts/AddExpr
         6: ifeq          39
         9: aload_2       
        10: checkcast     #60                 // class adts/AddExpr
        13: astore_3      
        14: aload_3       
        15: invokevirtual #63                 // Method adts/AddExpr.x:()I
        18: istore        4
        20: aload_3       
        21: invokevirtual #66                 // Method adts/AddExpr.y:()I
        24: istore        5
        26: iload         4
        28: iload         5
        30: iadd          </code></pre>
    <p>So, instead of calling <code>unapply</code> to presumably check whether <code>AddExpr</code>
    matches, scalac checks and casts its argument to <code>AddExpr</code>.  Why does
    it do that?  Let’s see if we could use <code>AddExpr.unapply</code> instead.</p>
    <pre><code class="nohighlight"><span class="identifier">scala</span><span>&gt; </span><span class="type-name">AddExpr</span><span>.</span><span class="identifier">unapply</span><span> </span><span class="identifier">_</span><span>
</span><span class="identifier">res4</span><span>: </span><span class="identifier">adts</span><span>.</span><span class="type-name">AddExpr</span><span> =&gt; </span><span class="type-name">Option</span><span>[(</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)] = &lt;</span><span class="identifier">function1</span><span>&gt;</span></code></pre>
    <p>In other words, the <code>unapply</code> call can’t tell you whether an <code>Expr</code> is
    an <code>AddExpr</code>; it can’t be called with arbitrary <code>Expr</code>.</p>
    <p>The only actual check here is inserted by scalac as part of compiling
    the pattern match expression, and it is a type test, supposedly
    verboten under Scalazzi rules.  <code>headOption</code>, too, is implemented with
    type tests and casts, not <code>unapply</code> calls.</p>
    <p>We’ve exhorted Scala users to avoid type tests, but then turn around
    and say that type tests are OK!  What’s going on?</p>
    
    <h2 id="an-equivalent-form" class="section"><a class="anchor-link" href="#an-equivalent-form"><code class="fas fa-link fa-sm"></code></a>An equivalent form</h2>
    <p>In every case where we use pattern matching on an ADT, there’s an
    equivalent way we could write the expression without pattern matching,
    by adding an encoding of the whole ADT as a method on the class or
    trait we use as the base type.  Let’s redefine the <code>Option</code> type with
    such a method to see how this is done.</p>
    <pre><code class="nohighlight"><span class="keyword">sealed</span><span> </span><span class="keyword">abstract</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Maybe</span><span>[</span><span class="type-name">T</span><span>] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">fold</span><span>[</span><span class="type-name">Z</span><span>](</span><span class="identifier">nothing</span><span>: =&gt; </span><span class="type-name">Z</span><span>, </span><span class="identifier">just</span><span>: </span><span class="type-name">T</span><span> =&gt; </span><span class="type-name">Z</span><span>): </span><span class="type-name">Z</span><span>
}

</span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">MNothing</span><span>[</span><span class="type-name">T</span><span>]() </span><span class="keyword">extends</span><span> </span><span class="type-name">Maybe</span><span>[</span><span class="type-name">T</span><span>] {
  </span><span class="keyword">override</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">fold</span><span>[</span><span class="type-name">Z</span><span>](</span><span class="identifier">nothing</span><span>: =&gt; </span><span class="type-name">Z</span><span>, </span><span class="identifier">just</span><span>: </span><span class="type-name">T</span><span> =&gt; </span><span class="type-name">Z</span><span>): </span><span class="type-name">Z</span><span> =
    </span><span class="identifier">nothing</span><span>
}

</span><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Just</span><span>[</span><span class="type-name">T</span><span>](</span><span class="identifier">get</span><span>: </span><span class="type-name">T</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Maybe</span><span>[</span><span class="type-name">T</span><span>] {
  </span><span class="keyword">override</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">fold</span><span>[</span><span class="type-name">Z</span><span>](</span><span class="identifier">nothing</span><span>: =&gt; </span><span class="type-name">Z</span><span>, </span><span class="identifier">just</span><span>: </span><span class="type-name">T</span><span> =&gt; </span><span class="type-name">Z</span><span>): </span><span class="type-name">Z</span><span> =
    </span><span class="identifier">just</span><span>(</span><span class="identifier">get</span><span>)
}</span></code></pre>
    <p>It’s key to our reasoning that we completely avoid <code>match</code> in our
    implementations; in other words, the <code>fold</code> is <em>matchless</em>.</p>
    <p>With the <code>fold</code> method, the following two expressions are equivalent,
    notwithstanding scalac’s difficulty optimizing the latter, even in the
    presence of inlining.</p>
    <pre><code class="nohighlight"><span>(</span><span class="identifier">selector</span><span>: </span><span class="type-name">Maybe</span><span>[</span><span class="type-name">A</span><span>]) </span><span class="keyword">match</span><span> {
  </span><span class="keyword">case</span><span> </span><span class="type-name">MNothing</span><span>() =&gt; </span><span class="string-literal">&quot;default case&quot;</span><span>
  </span><span class="keyword">case</span><span> </span><span class="type-name">Just</span><span>(</span><span class="identifier">x</span><span>) =&gt; </span><span class="identifier">justcase</span><span>(</span><span class="identifier">x</span><span>)
}

</span><span class="identifier">selector</span><span>.</span><span class="identifier">fold</span><span>(</span><span class="string-literal">&quot;default case&quot;</span><span>, </span><span class="identifier">x</span><span> =&gt; </span><span class="identifier">justcase</span><span>(</span><span class="identifier">x</span><span>))</span></code></pre>
    <p>It’s a simple formula: the fold takes as many arguments as there are
    cases, always returns the given, sole type parameter, and each
    argument is a function that results in that same parameter.  There’s a
    free theorem that a <code>fold</code> implementation on data structures without
    recursion, like <code>Maybe</code>, can only invoke one of these arguments and
    return the result directly, just as the pattern match does.</p>
    <p>If you prefer the clarity of named cases, just use Scala’s named
    arguments.  Here’s that last fold:</p>
    <pre><code class="nohighlight"><span class="identifier">selector</span><span>.</span><span class="identifier">fold</span><span>(</span><span class="identifier">nothing</span><span> = </span><span class="string-literal">&quot;default case&quot;</span><span>,
              </span><span class="identifier">just</span><span> = </span><span class="identifier">x</span><span> =&gt; </span><span class="identifier">justcase</span><span>(</span><span class="identifier">x</span><span>))</span></code></pre>
    
    <h2 id="gadt-folds" class="section"><a class="anchor-link" href="#gadt-folds"><code class="fas fa-link fa-sm"></code></a>GADT folds</h2>
    <p>Encoding <code>Expr</code> is a little bit more complicated.  For the full power
    of the type, we have to turn to <code>Leibniz</code> to encode the matchless
    <code>fold</code>.</p>
    <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">scalaz</span><span>.</span><span class="type-name">Leibniz</span><span>, </span><span class="type-name">Leibniz</span><span>.{===, </span><span class="identifier">refl</span><span>}

</span><span class="keyword">sealed</span><span> </span><span class="keyword">abstract</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Expr2</span><span>[</span><span class="type-name">T</span><span>] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">fold</span><span>[</span><span class="type-name">Z</span><span>](</span><span class="identifier">add</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span> === </span><span class="type-name">T</span><span>) =&gt; </span><span class="type-name">Z</span><span>,
              </span><span class="identifier">concat</span><span>: (</span><span class="type-name">String</span><span>, </span><span class="type-name">String</span><span>, </span><span class="type-name">String</span><span> === </span><span class="type-name">T</span><span>) =&gt; </span><span class="type-name">Z</span><span>): </span><span class="type-name">Z</span><span>
}</span></code></pre>
    <p>What does this mean?  The type <code>Int === T</code>, seen in the <code>add</code> argument
    signature, is inhabited if and only if the type <code>T</code> <strong>is</strong> the type
    <code>Int</code>.  So an implementation of <code>fold</code> can only call the <code>add</code>
    function if it can prove that type equality.  There is, of course, one
    that can:</p>
    <pre><code class="nohighlight"><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">AddExpr2</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr2</span><span>[</span><span class="type-name">Int</span><span>] {
  </span><span class="keyword">override</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">fold</span><span>[</span><span class="type-name">Z</span><span>](</span><span class="identifier">add</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span> === </span><span class="type-name">Int</span><span>) =&gt; </span><span class="type-name">Z</span><span>,
              </span><span class="identifier">concat</span><span>: (</span><span class="type-name">String</span><span>, </span><span class="type-name">String</span><span>, </span><span class="type-name">String</span><span> === </span><span class="type-name">Int</span><span>) =&gt; </span><span class="type-name">Z</span><span>): </span><span class="type-name">Z</span><span> =
    </span><span class="identifier">add</span><span>(</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>, </span><span class="identifier">refl</span><span>)
}</span></code></pre>
    <p>Not only does <code>AddExpr2</code> know that <code>Expr2</code>’s type parameter is <code>Int</code>,
    we must make the type substitution when implementing methods from
    <code>Expr2</code>!  At that point it is enough to mention <code>refl</code>, the evidence
    that every type is equal to itself, to satisfy <code>add</code>’s signature.</p>
    <p>This may seem a little magical, but it is no less prosaic than
    implementing <code>java.lang.Comparable</code> by making this substitution.  So
    you can do this sort of thing every day even in Java.</p>
    <pre><code class="nohighlight"><span class="keyword">public</span><span> </span><span class="keyword">interface</span><span> </span><span class="type-name">Comparable</span><span>&lt;</span><span class="type-name">T</span><span>&gt; {
  </span><span class="type-name">int</span><span> </span><span class="identifier">compareTo</span><span>(</span><span class="type-name">T</span><span> </span><span class="identifier">o</span><span>);
}

</span><span class="keyword">class</span><span> </span><span class="type-name">MyData</span><span> </span><span class="keyword">implements</span><span> </span><span class="type-name">Comparable</span><span>&lt;</span><span class="type-name">MyData</span><span>&gt; {
  </span><span class="annotation">@Override</span><span>
  </span><span class="keyword">public</span><span> </span><span class="type-name">int</span><span> </span><span class="identifier">compareTo</span><span>(</span><span class="type-name">MyData</span><span> </span><span class="identifier">o</span><span>) {   </span><span class="comment">// note T is replaced by MyData
</span><span>    </span><span class="comment">// ...
</span><span>  }
}</span></code></pre>
    <p>If only Java had higher kinds, you could go the rest of the way and
    actually implement
    <a href="https://www.haskell.org/haskellwiki/Generalised_algebraic_datatype#Motivating_example">GADTs</a>.</p>
    <p>Moving on, let’s see another case for <code>Expr2</code>, and finally to tie it
    all together, <code>eval2</code> with some extra constant data in for good
    measure.</p>
    <pre><code class="nohighlight"><span class="keyword">final</span><span> </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">ConcatExpr2</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">String</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr2</span><span>[</span><span class="type-name">String</span><span>] {
  </span><span class="keyword">override</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">fold</span><span>[</span><span class="type-name">Z</span><span>](</span><span class="identifier">add</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span> === </span><span class="type-name">String</span><span>) =&gt; </span><span class="type-name">Z</span><span>,
              </span><span class="identifier">concat</span><span>: (</span><span class="type-name">String</span><span>, </span><span class="type-name">String</span><span>, </span><span class="type-name">String</span><span> === </span><span class="type-name">String</span><span>) =&gt; </span><span class="type-name">Z</span><span>): </span><span class="type-name">Z</span><span> =
    </span><span class="identifier">concat</span><span>(</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>, </span><span class="identifier">refl</span><span>)
}

</span><span class="keyword">def</span><span> </span><span class="declaration-name">eval2</span><span>[</span><span class="type-name">T</span><span>](</span><span class="identifier">ex</span><span>: </span><span class="type-name">Expr2</span><span>[</span><span class="type-name">T</span><span>]): </span><span class="type-name">T</span><span> =
  </span><span class="identifier">ex</span><span>.</span><span class="identifier">fold</span><span>((</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>, </span><span class="identifier">intIsT</span><span>) =&gt; </span><span class="identifier">intIsT</span><span>(</span><span class="number-literal">1</span><span> + </span><span class="identifier">x</span><span> + </span><span class="identifier">y</span><span>),
          (</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>, </span><span class="identifier">strIsT</span><span>) =&gt; </span><span class="identifier">strIsT</span><span>(</span><span class="string-literal">&quot;one&quot;</span><span> + </span><span class="identifier">x</span><span> + </span><span class="identifier">y</span><span>))</span></code></pre>
    <p>Using the <code>Leibniz</code> proof is, unfortunately, more involved than
    producing it in the fold implementations.  See my previous posts,
    <a href="type_equality_to_leibniz.html">“A function from type equality to Leibniz”</a>
    and
    <a href="higher_leibniz.html">“Higher Leibniz”</a>,
    for many
    details on applying <code>Leibniz</code> proof to make type transformations.</p>
    <p>While the pattern matching <code>eval</code> didn’t have to explicitly apply type
    equality evidence -- it <em>just knew</em> that <code>Int</code> was <code>T</code> when the
    <code>IntExpr</code> pattern matched -- Scala has holes in its implementation,
    discussed in the aforementioned posts on <code>Leibniz</code>, that sometimes
    make the above implementation strategy an attractive choice even
    though pattern matching is available.</p>
    
    <h2 id="we-could-but-that-s-good-enough-so-we-won-t" class="section"><a class="anchor-link" href="#we-could-but-that-s-good-enough-so-we-won-t"><code class="fas fa-link fa-sm"></code></a>We could, but that’s good enough, so we won’t</h2>
    <p>You might have noticed that adding another case to <code>Expr</code> caused us
    not only to implement an extra <code>fold</code>, but to add another argument to
    the base <code>fold</code> to represent the new case, and then go through every
    implementation to add that argument.  This isn’t so bad for just two
    cases, but indeed has quadratic growth, to the point that adding a new
    case to a large datatype is a majorly annoying project all by itself.</p>
    <p>There is an interesting property of <code>fold</code>, though: the strategy isn’t
    available for our first function, <code>revmaybe</code>, to discriminate
    arguments of arbitrary type!  To do that, we would have to add a
    signature like this to <code>Any</code>.</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">fold</span><span>[</span><span class="type-name">Z</span><span>](</span><span class="identifier">int</span><span>: </span><span class="type-name">Int</span><span> =&gt; </span><span class="type-name">Z</span><span>, </span><span class="identifier">any</span><span>: </span><span class="type-name">Any</span><span> =&gt; </span><span class="type-name">Z</span><span>): </span><span class="type-name">Z</span><span> = </span><span class="identifier">any</span><span>(</span><span class="keyword">this</span><span>)
</span><span class="comment">// and, in the body of class Int
</span><span class="keyword">override</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">fold</span><span>[</span><span class="type-name">Z</span><span>](</span><span class="identifier">int</span><span>: </span><span class="type-name">Int</span><span> =&gt; </span><span class="type-name">Z</span><span>, </span><span class="identifier">any</span><span>: </span><span class="type-name">Any</span><span> =&gt; </span><span class="type-name">Z</span><span>): </span><span class="type-name">Z</span><span> = </span><span class="identifier">int</span><span>(</span><span class="keyword">this</span><span>)</span></code></pre>
    <p>Obviously, you cannot do this.</p>
    <p>You can only add <code>fold</code> methods to types you know; I can only call
    <code>fold</code> in <code>expr2</code> by virtue of the fact that I know that the argument
    has type <code>Expr2[T]</code> for some <code>T</code>.  If the argument was just <code>T</code>, I
    wouldn’t have enough static type information to call <code>fold</code>.  So the
    use of <code>fold</code>s doesn’t break parametricity.  Equivalently, <strong>a pattern
    match that could be implemented using a matchless fold also does not
    break parametricity</strong>.</p>
    <p>As we have seen, it is unfortunately inconvenient to actually go
    through the bother of writing <code>fold</code> methods, when pattern matching is
    there.  But it is enough to reason that <em>we could</em> write a matchless
    <code>fold</code> and replace the pattern matching with it, to prove that the
    pattern matching is safe, no matter how many underlying type tests
    scalac might use to implement it.</p>
    <p>A simple test follows: <strong>if you could write a matchless fold, and use
    that instead, the pattern match is type-safe</strong>.</p>
    
    <h2 id="a-selector-subtlety" class="section"><a class="anchor-link" href="#a-selector-subtlety"><code class="fas fa-link fa-sm"></code></a>A selector subtlety</h2>
    <p>Here’s a pattern match that violates parametricity.</p>
    <pre><code class="nohighlight"><span class="identifier">selector</span><span> </span><span class="keyword">match</span><span> {
  </span><span class="keyword">case</span><span> </span><span class="type-name">MNothing</span><span>() =&gt; </span><span class="string-literal">&quot;default case&quot;</span><span>
  </span><span class="keyword">case</span><span> </span><span class="type-name">Just</span><span>(</span><span class="identifier">x</span><span>) =&gt; </span><span class="identifier">justcase</span><span>(</span><span class="identifier">x</span><span>)
}</span></code></pre>
    <p>Wait, but didn’t we rewrite that using a <code>fold</code> earlier?  Not quite.
    Oh, I didn’t mention?  The type of <code>selector</code> is <code>T</code>, because we’re in
    a function like this:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">notIdentity</span><span>[</span><span class="type-name">T</span><span>](</span><span class="identifier">selector</span><span>: </span><span class="type-name">T</span><span>) =
  </span><span class="comment">// match expression above goes here</span></code></pre>
    <p>Scala will permit this pattern match to go forward.  It doesn’t
    require us to prove that the selector is of the ADT root type we
    happened to define; that’s an arbitrary point as far as Scala’s
    subtyping system is concerned.  All that is required is that the
    static type of <code>selector</code> be a supertype of each of <code>MNothing[_]</code> and
    <code>Just[_]</code>, which <code>T</code> is, not being known to be more refined than
    <code>Any</code>.</p>
    <p>The test works here, though!  What is ambiguous to scalac is a bright
    line in our reasoning. We can’t define a matchless <code>fold</code> that can be
    invoked on this <code>selector</code>, so we reach the correct conclusion, that
    the match violates parametricity.</p>
    
    <h2 id="the-rule-revisited" class="section"><a class="anchor-link" href="#the-rule-revisited"><code class="fas fa-link fa-sm"></code></a>The rule revisited</h2>
    <p>So we’ve carved out a clear “exception” to the “no type tests”
    Scalazzi rule, and seen that it isn’t an exception at all.  There’s a
    straightforward test you can apply to your pattern matches,</p>
    <p><strong>If and only if I could, hypothetically, write a matchless fold, or
    use an existing one, and rewrite this in its terms, this pattern
    match is safe.</strong></p>
    <p>but beware the subtle case where the match’s selector has a wider type
    than you anticipated.</p>
    <p>Finally, this is a rule specifically about expressions that don’t
    violate our ability to reason about code.  This doesn’t hold for
    arbitrary type-unsafe rewrites: that you could write a program safely
    means you <em>should</em> write it safely.  Unlike arbitrary rewrites into
    nonfunctional code, the pattern match uses no
    non-referentially-transparent and no genuinely non-parametric
    expressions.</p>
    <p><em>This article was tested with Scala 2.11.4 and Scalaz 7.1.0.</em></p>
  </div>
</div>
<div class="bulma-section bulma-container bulma-is-max-desktop">
  <div class="bulma-columns">
    
    <div class="bulma-column">
      <article class="bulma-media">
  
  <figure class="bulma-media-left">
    <p class="bulma-image bulma-is-64x64">
      <img class="bulma-is-rounded" src="https://github.com/S11001001.png" />
    </p>
  </figure>
  
  <div class="bulma-media-content">
    <div class="bulma-content">
      <p>
        <strong>Stephen Compall</strong>
        
      </p>
    </div>
    <nav class="bulma-level bulma-is-align-items-start">
      <div class="bulma-level-left bulma-is-flex-direction-row">
        
        
        <a class="bulma-level-item" href="http://github.com/S11001001">
          <span class="bulma-icon bulma-is-small"><i class="fab fa-github"></i></span>
        </a>
        
        
        
        
      </div>
    </nav>
  </div>
</article>

    </div>
    
  </div>
</div>


  </main>
  <footer class="bulma-footer">
  <div class="bulma-columns">
    <div class="bulma-column bulma-is-half">
      Copyright 2026 Typelevel Foundation and <a href="https://github.com/typelevel/typelevel.github.com/graphs/contributors">contributors</a>.
      Licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> unless <a href="../colophon.html#license">noted otherwise</a>.
    </div>
    <div class="bulma-column">
      <ul>
        <li><a href="../projects/">Project Index</a></li>
        <li><a href="#">Documentation</a></li>
        <li><a href="#">Contributing</a></li>
      </ul>
    </div>
    <div class="bulma-column">
      <ul>
        <li><a href="../code-of-conduct/">Code of Conduct</a></li>
        <li><a href="../security.html">Security Policy</a></li>
        <li><a href="../colophon.html">Colophon</a></li>
      </ul>
    </div>
  </div>
  <div class="bulma-has-text-centered">
    <div>Find us on ...</div>
    <div>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://github.com/typelevel">
        <i class="fab fa-github fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://discord.gg/pey2hnSQGS">
        <i class="fab fa-discord fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://bsky.app/profile/typelevel.org">
        <i class="fab fa-bluesky fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://fosstodon.org/@typelevel">
        <i class="fab fa-mastodon fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://www.youtube.com/@typelevel">
        <i class="fab fa-youtube fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current"
        href="https://linkedin.com/company/typelevel-foundation">
        <i class="fab fa-linkedin fa-2x"></i>
      </a>
    </div>
  </div>
</footer>

</body>

</html>

