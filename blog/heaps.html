<!DOCTYPE html>
<html lang="en" data-bulma-theme="light">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" href="../img/favicon.ico" sizes="32x32">
  <link rel="icon" href="../img/favicon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="../img/apple-touch-icon.png">

  <script src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/js/all.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/fontawesome.min.css"
    rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.28/dist/katex.min.css" integrity="sha384-Wsr4Nh3yrvMf2KCebJchRJoVo1gTU6kcP05uRSh5NV3sj9+a8IomuJoQzf3sMq4T" crossorigin="anonymous">

  <link rel="stylesheet" href="../main.css">
  <link rel="stylesheet" href="../css/code.css">
  <link rel="stylesheet" href="../search/docs.css">
  <script src="../main.js"></script>

  <title>API Design for Heaps (aka Priority Queues)</title>
</head>

<body class="bulma-is-flex bulma-is-flex-direction-column">
  <nav class="bulma-navbar" role="navigation" aria-label="main navigation">
  <div class="bulma-navbar-brand">
    <a class="bulma-navbar-item" href="../">
      <img src="../img/logo.svg" />
    </a>

    <a role="button" class="bulma-navbar-burger" aria-label="menu" aria-expanded="false" data-target="navMenu"
      onClick="handleBurgerClick(this)">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>
  <div class="bulma-navbar-menu" id="navMenu">
    <div class="bulma-navbar-start">

    </div>
    <div class="bulma-navbar-end">
      <!-- <div class="bulma-navbar-item"><a class="bulma-button bulma-is-rounded bulma-is-primary bulma-has-text-light">Get Started</a></div> -->
      <!-- <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text">Learn</a></div> -->
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text" href="../community/">Community</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text" href="../foundation/">Foundation</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text" href="index.html">Blog</a></div>
      <div class="bulma-navbar-item">
        <a id="search-top-bar" class="bulma-button bulma-is-text" aria-label="Search" onclick="showSearchModal()">
          <span class="bulma-icon bulma-is-small">
            <i class="fas fa-magnifying-glass"></i>
          </span>
        </a>
      </div>
    </div>
  </div>
</nav>

<!-- Search Modal -->
<div id="search-modal" class="bulma-modal bulma-is-justify-content-flex-start bulma-pt-6 bulma-pb-6">
  <div class="bulma-modal-background bulma-is-align-items-flex-start" onclick="hideSearchModal()"></div>
  <div class="bulma-modal-card">
    <header class="bulma-modal-card-head">
      <p class="bulma-control bulma-has-icons-left bulma-is-flex-grow-1">
        <input id="search-input" class="bulma-input bulma-is-medium bulma-is-primary" type="search" autocomplete="off" oninput="onSearchInput(event)">
        <span class="bulma-icon bulma-is-left bulma-has-text-primary">
          <i class="fas fa-magnifying-glass"></i>
        </span>
      </p>
    </header>
    <section id="search-results" class="bulma-modal-card-body">
    </section>
    <footer class="bulma-modal-card-foot bulma-is-justify-content-space-between">
      <span class="bulma-has-text-grey bulma-is-size-7">
        <kbd class="bulma-tag">/</kbd> to open search &nbsp;
        <kbd class="bulma-tag">Esc</kbd> to close
      </span>
    </footer>
  </div>
</div>

  <main class="bulma-is-flex-grow-1">
    
<section class="bulma-hero bulma-is-primary bulma-is-bold">
  <div class="bulma-hero-body bulma-container bulma-is-max-desktop">
    <p class="bulma-title bulma-has-text-light">API Design for Heaps (aka Priority Queues)</p>
    <p class="blog-post-byline bulma-has-text-light bulma-subtitle">
      by
      
        Chris Okasaki<span class="delimiter">,</span><span class="last-delimiter"> &</span>
      
      on November 17, 2016
    </p>
     
      <span class="bulma-tag">technical</span>
     
  </div>
</section>
<div class="bulma-section bulma-container bulma-is-max-desktop">
  <div class="blog-post bulma-content">
    <h1 id="api-design-for-heaps-aka-priority-queues" class="title">API Design for Heaps (aka Priority Queues)</h1>
    <p><em>This is a guest post by Chris Okasaki. It was initially published as the <a href="https://github.com/chrisokasaki/scads/blob/e78233ac6a787b7c66b44cd6139392418b214eb9/design/heaps.md">design document</a> behind <a href="https://github.com/chrisokasaki/scads">scads</a>. It is being republished here with the permission of the original author.</em></p>
    <p>A heap (or priority queue) is a collection of elements ordered by some <code>Ordering</code>, optimized for retrieving the first element according to that ordering.
    Duplicate elements are allowed.
    Applications vary in whether they need the first element to be the smallest or the biggest element according to the ordering, so both variations should be easy to use.
    (However, any given heap is expected to offer easy access to either the smallest element only or the biggest element only, not both at the same time.)
    I will consider immutable heaps in this document, but the core issues discussed below apply to both immutable heaps and mutable heaps.</p>
    <p>Even if an element type has a natural ordering, that ordering may not be the one we want to use, so we must allow the user to specify the ordering.</p>
    
    <h2 id="problem-1-don-t-mix-two-different-orderings-in-the-same-heap" class="section"><a class="anchor-link" href="#problem-1-don-t-mix-two-different-orderings-in-the-same-heap"><code class="fas fa-link fa-sm"></code></a>Problem 1: Don&#39;t mix two different orderings in the same heap</h2>
    <p>Here is a strawman design for a very simple heap API:</p>
    <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">Heap</span><span>[</span><span class="type-name">Elem</span><span>] {  </span><span class="comment">// WARNING: THIS IS BROKEN!!!
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">isEmpty</span><span>(</span><span class="keyword">implicit</span><span> </span><span class="identifier">ord</span><span>: </span><span class="type-name">Ordering</span><span>[</span><span class="type-name">Elem</span><span>]): </span><span class="type-name">Boolean</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">add</span><span>(</span><span class="identifier">elem</span><span>: </span><span class="type-name">Elem</span><span>)(</span><span class="keyword">implicit</span><span> </span><span class="identifier">ord</span><span>: </span><span class="type-name">Ordering</span><span>[</span><span class="type-name">Elem</span><span>]): </span><span class="type-name">Heap</span><span>[</span><span class="type-name">Elem</span><span>]
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">first</span><span>(</span><span class="keyword">implicit</span><span> </span><span class="identifier">ord</span><span>: </span><span class="type-name">Ordering</span><span>[</span><span class="type-name">Elem</span><span>]): </span><span class="type-name">Elem</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">rest</span><span>(</span><span class="keyword">implicit</span><span> </span><span class="identifier">ord</span><span>: </span><span class="type-name">Ordering</span><span>[</span><span class="type-name">Elem</span><span>]): </span><span class="type-name">Heap</span><span>[</span><span class="type-name">Elem</span><span>]
}

</span><span class="comment">// factory method, probably in some companion object
</span><span class="keyword">def</span><span> </span><span class="declaration-name">empty</span><span>[</span><span class="type-name">Elem</span><span>](</span><span class="keyword">implicit</span><span> </span><span class="identifier">ord</span><span>: </span><span class="type-name">Ordering</span><span>[</span><span class="type-name">Elem</span><span>]): </span><span class="type-name">Heap</span><span>[</span><span class="type-name">Elem</span><span>] = ???</span></code></pre>
    <p>You may think it strange that all of these methods are taking an <code>ord</code> parameter.
    From a Scala point of view, that doesn&#39;t make much sense.
    But you can find variations of this design in many implementations of heaps on GitHub, including in the well-respected Scalaz library.
    Why? As far as I can tell, the answer is <em>because Haskell does it that way</em>.
    Here&#39;s the equivalent design in Haskell:</p>
    <pre><code class="nohighlight"><span class="keyword">type</span><span> </span><span class="type-name">Heap</span><span> </span><span class="identifier">a</span><span>
</span><span class="identifier">empty</span><span>   :: </span><span class="type-name">Ord</span><span> </span><span class="identifier">a</span><span> =&gt; </span><span class="type-name">Heap</span><span> </span><span class="identifier">a</span><span>
</span><span class="identifier">isEmpty</span><span> :: </span><span class="type-name">Ord</span><span> </span><span class="identifier">a</span><span> =&gt; </span><span class="type-name">Heap</span><span> </span><span class="identifier">a</span><span> -&gt; </span><span class="type-name">Bool</span><span>
</span><span class="identifier">add</span><span>     :: </span><span class="type-name">Ord</span><span> </span><span class="identifier">a</span><span> =&gt; </span><span class="identifier">a</span><span> -&gt; </span><span class="type-name">Heap</span><span> </span><span class="identifier">a</span><span> -&gt; </span><span class="type-name">Heap</span><span> </span><span class="identifier">a</span><span>
</span><span class="identifier">first</span><span>   :: </span><span class="type-name">Ord</span><span> </span><span class="identifier">a</span><span> =&gt; </span><span class="type-name">Heap</span><span> </span><span class="identifier">a</span><span> -&gt; </span><span class="identifier">a</span><span>
</span><span class="identifier">rest</span><span>    :: </span><span class="type-name">Ord</span><span> </span><span class="identifier">a</span><span> =&gt; </span><span class="type-name">Heap</span><span> </span><span class="identifier">a</span><span> -&gt; </span><span class="type-name">Heap</span><span> </span><span class="identifier">a</span></code></pre>
    <p>In Haskell, this makes perfect sense.
    Behind the scenes, each method takes an <code>Ord</code> dictionary as a hidden parameter.
    But there&#39;s one critical difference between Haskell and Scala: in Haskell, there can only be a <em>single</em> ordering for an element type, but in Scala, there can be <em>many</em> orderings for the same element type.</p>
    <p>For example, consider this Scala code:</p>
    <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">ord1</span><span> = </span><span class="type-name">Ordering</span><span>.</span><span class="type-name">Int</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">ord2</span><span> = </span><span class="identifier">ord1</span><span>.</span><span class="identifier">reverse</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">heap1</span><span> = </span><span class="identifier">empty</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="identifier">ord1</span><span>).</span><span class="identifier">add</span><span>(</span><span class="number-literal">5</span><span>)(</span><span class="identifier">ord1</span><span>).</span><span class="identifier">add</span><span>(</span><span class="number-literal">7</span><span>)(</span><span class="identifier">ord1</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">heap2</span><span> = </span><span class="identifier">heap1</span><span>.</span><span class="identifier">add</span><span>(</span><span class="number-literal">4</span><span>)(</span><span class="identifier">ord2</span><span>)
</span><span class="identifier">println</span><span>(</span><span class="identifier">heap2</span><span>.</span><span class="identifier">first</span><span>)</span></code></pre>
    <p>What should this print?
    Of course, that depends on the details of the implementation, but you would expect it to print either 4 (the smallest element) or 7 (the biggest element).
    However, because one ordering was used for two of the <code>add</code>s and the opposite ordering was used for the third <code>add</code>, there&#39;s an excellent chance that the actual result will be 5, which is the wrong answer for both orderings.</p>
    <p>The magic of implicit parameters is that you usually don&#39;t need to pass them explicitly.
    But (A) there&#39;s nothing to stop you from doing so, and (B) there&#39;s nothing to prevent you from calling methods in different scopes with different orderings.
    No, if you&#39;re anything like me, the possibility that this could happen by accident is making your skin crawl.
    Surely, the API should prevent this from happening!</p>
    <p>Fortunately, this problem is very easy to fix.
    <em>Only the <code>empty</code> method should take an ordering.</em>
    Once that initial heap has been created, all future heaps derived from that heap via any sequence of <code>add</code>s or <code>rest</code>s should use the same ordering.
    With this change, the API becomes:</p>
    <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">Heap</span><span>[</span><span class="type-name">Elem</span><span>] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">isEmpty</span><span>: </span><span class="type-name">Boolean</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">add</span><span>(</span><span class="identifier">elem</span><span>: </span><span class="type-name">Elem</span><span>): </span><span class="type-name">Heap</span><span>[</span><span class="type-name">Elem</span><span>]
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">first</span><span>: </span><span class="type-name">Elem</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">rest</span><span>: </span><span class="type-name">Heap</span><span>[</span><span class="type-name">Elem</span><span>]
}

</span><span class="comment">// factory method, probably in some companion object
</span><span class="keyword">def</span><span> </span><span class="declaration-name">empty</span><span>[</span><span class="type-name">Elem</span><span>](</span><span class="keyword">implicit</span><span> </span><span class="identifier">ord</span><span>: </span><span class="type-name">Ordering</span><span>[</span><span class="type-name">Elem</span><span>]): </span><span class="type-name">Heap</span><span>[</span><span class="type-name">Elem</span><span>] = ???</span></code></pre>
    <p>Yay! That is both simpler and safer.</p>
    
    <h2 id="problem-2-merge" class="section"><a class="anchor-link" href="#problem-2-merge"><code class="fas fa-link fa-sm"></code></a>Problem 2: <code>merge</code></h2>
    <p>Another operation supported by many kinds of heaps is <code>merge</code>, which combines two heaps into a single heap.
    Examples of heaps supporting merge include leftist heaps, skew heaps, binomial heaps (aka binomial queues), Fibonacci heaps, etc.</p>
    <p>We can easily add <code>merge</code> to the existing <code>Heap[Elem]</code> trait.</p>
    <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">Heap</span><span>[</span><span class="type-name">Elem</span><span>] {
  ...
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">merge</span><span>(</span><span class="identifier">other</span><span>: </span><span class="type-name">Heap</span><span>[</span><span class="type-name">Elem</span><span>]): </span><span class="type-name">Heap</span><span>[</span><span class="type-name">Elem</span><span>]
}</span></code></pre>
    <p>However, there are at last two problems with this.
    First, traits allow for subclassing, so we might have several different implementations, such as leftist heaps and binomial heaps.
    But we only want to merge leftist heaps with leftist heaps and binomial heaps with binomial heaps&amp;mdash;we do <em>not</em> want to merge leftist heaps with binomial heaps.</p>
    <p>There are several ways to address this problem.
    For example, leftist heaps and binomial heaps could just use completely separate trait hierarchies, and each could use a <code>sealed trait</code> to prevent this unwanted mixing of types.</p>
    <p>But the code duplication this would entail is unsatisfying.
    It would also make it more difficult to share code (such as a testing harness) between different implementations.</p>
    <p>Alternatively, we can control the types more precisely by adding a second type parameter for the specific representation being used, as in:</p>
    <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">MHeap</span><span>[</span><span class="type-name">Elem</span><span>, </span><span class="type-name">Heap</span><span>] {
  </span><span class="comment">// MHeap is &quot;Mergeable Heap&quot;
</span><span>  </span><span class="comment">// Heap is the specific Heap representation being used
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">isEmpty</span><span>: </span><span class="type-name">Boolean</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">add</span><span>(</span><span class="identifier">elem</span><span>: </span><span class="type-name">Elem</span><span>): </span><span class="type-name">Heap</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">first</span><span>: </span><span class="type-name">Elem</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">rest</span><span>: </span><span class="type-name">Heap</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">merge</span><span>(</span><span class="identifier">other</span><span>: </span><span class="type-name">Heap</span><span>): </span><span class="type-name">Heap</span><span>
}

</span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">LeftistHeap</span><span>[</span><span class="type-name">Elem</span><span>] </span><span class="keyword">extends</span><span> </span><span class="type-name">MHeap</span><span>[</span><span class="type-name">Elem</span><span>, </span><span class="type-name">LeftistHeap</span><span>[</span><span class="type-name">Elem</span><span>]]

</span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">BinomialHeap</span><span>[</span><span class="type-name">Elem</span><span>] </span><span class="keyword">extends</span><span> </span><span class="type-name">MHeap</span><span>[</span><span class="type-name">Elem</span><span>, </span><span class="type-name">BinomialHeap</span><span>[</span><span class="type-name">Elem</span><span>]]</span></code></pre>
    <p>Because of the extra type parameter, a leftist heap and binomial heap are incompatible and cannot be merged.</p>
    
    <h2 id="problem-3-merge-continued" class="section"><a class="anchor-link" href="#problem-3-merge-continued"><code class="fas fa-link fa-sm"></code></a>Problem 3: <code>merge</code> (continued)</h2>
    <p>There&#39;s a second problem with <code>merge</code>.  A particular implementation, such as leftist heaps, would provide a factory method for creating a new heap.</p>
    <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">LeftistHeap</span><span> { </span><span class="comment">// companion object
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">empty</span><span>[</span><span class="type-name">Elem</span><span>](</span><span class="keyword">implicit</span><span> </span><span class="identifier">ord</span><span>: </span><span class="type-name">Ordering</span><span>[</span><span class="type-name">Elem</span><span>]): </span><span class="type-name">LeftistHeap</span><span>[</span><span class="type-name">Elem</span><span>] = ???
}</span></code></pre>
    <p>Because of the <code>MHeap</code> definition, we can&#39;t <code>merge</code> a leftist heap with a binomial heap.
    But now we&#39;ve re-introduced the problem of incompatible orderings!</p>
    <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">ord1</span><span> = </span><span class="type-name">Ordering</span><span>.</span><span class="type-name">Int</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">ord2</span><span> = </span><span class="identifier">ord1</span><span>.</span><span class="identifier">reverse</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">heap1</span><span> = </span><span class="identifier">empty</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="identifier">ord1</span><span>).</span><span class="identifier">add</span><span>(</span><span class="number-literal">5</span><span>).</span><span class="identifier">add</span><span>(</span><span class="number-literal">7</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">heap2</span><span> = </span><span class="identifier">empty</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="identifier">ord2</span><span>).</span><span class="identifier">add</span><span>(</span><span class="number-literal">6</span><span>).</span><span class="identifier">add</span><span>(</span><span class="number-literal">4</span><span>)
</span><span class="keyword">var</span><span> </span><span class="identifier">heap3</span><span> = </span><span class="identifier">heap1</span><span>.</span><span class="identifier">merge</span><span>(</span><span class="identifier">heap2</span><span>)
</span><span class="keyword">while</span><span> (!</span><span class="identifier">heap3</span><span>.</span><span class="identifier">isEmpty</span><span>) {
  </span><span class="identifier">println</span><span>(</span><span class="identifier">heap3</span><span>.</span><span class="identifier">first</span><span>)
  </span><span class="identifier">heap3</span><span> = </span><span class="identifier">heap3</span><span>.</span><span class="identifier">rest</span><span>
}</span></code></pre>
    <p>Notice that <code>heap1</code> and <code>heap2</code> were created with opposite orderings.
    What happens if we merge them? Nothing good!
    The exact results depend on details of the implementation, but a likely result is that loop will print the elements in the order 5,6,4,7&amp;mdash;or maybe 5,7,6,4&amp;mdash;when it <em>should</em> print them in sorted order!</p>
    <p>We would really like to make this sort of situation impossible!
    Maybe we could test the orderings for object equality at runtime, and throw an exception if they&#39;re different?
    That could actually work for simple types like integers with a built-in ordering object.
    But for more complicated types, such as tuples, the orderings are generated on demand from the orderings of their constituent parts.
    And this generation is not memoized, so if we demand an ordering for, say, <code>(Int,String)</code> twice, we&#39;ll get two separate ordering objects, which will cause a false negative for our hypothetical dynamic equality check.</p>
    <p>No, we would really like to make merging two heaps with different orderings a type error.
    We can achieve this by making the notion of a factory explicit.
    The idea is that heaps can only be merged with other heaps from the same factory.
    Attempting to merge heaps from different factories will cause a type error.</p>
    <p>In code, we might express this as follows:</p>
    <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">HeapFactory</span><span> {
  </span><span class="keyword">type</span><span> </span><span class="type-name">Elem</span><span>
  </span><span class="keyword">type</span><span> </span><span class="type-name">Heap</span><span> &lt;: </span><span class="type-name">MHeap</span><span>[</span><span class="type-name">Elem</span><span>,</span><span class="type-name">Heap</span><span>]

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">empty</span><span>: </span><span class="type-name">Heap</span><span>
  </span><span class="comment">// plus other factory methods
</span><span>}

</span><span class="keyword">object</span><span> </span><span class="type-name">LeftistHeap</span><span> { </span><span class="comment">// companion object
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">factory</span><span>[</span><span class="type-name">E</span><span>](</span><span class="keyword">implicit</span><span> </span><span class="identifier">ord</span><span>: </span><span class="type-name">Ordering</span><span>[</span><span class="type-name">E</span><span>]): </span><span class="type-name">HeapFactory</span><span> { </span><span class="keyword">type</span><span> </span><span class="type-name">Elem</span><span> = </span><span class="type-name">E</span><span> } = ???
}</span></code></pre>
    <p>Now we can say:</p>
    <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">minHeaps</span><span> = </span><span class="type-name">LeftistHeap</span><span>.</span><span class="identifier">factory</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="type-name">Ordering</span><span>.</span><span class="type-name">Int</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">maxHeaps</span><span> = </span><span class="type-name">LeftistHeap</span><span>.</span><span class="identifier">factory</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="type-name">Ordering</span><span>.</span><span class="type-name">Int</span><span>.</span><span class="identifier">reverse</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">heap1</span><span> = </span><span class="identifier">minHeaps</span><span>.</span><span class="identifier">empty</span><span>.</span><span class="identifier">add</span><span>(</span><span class="number-literal">5</span><span>).</span><span class="identifier">add</span><span>(</span><span class="number-literal">7</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">heap2</span><span> = </span><span class="identifier">minHeaps</span><span>.</span><span class="identifier">empty</span><span>.</span><span class="identifier">add</span><span>(</span><span class="number-literal">6</span><span>).</span><span class="identifier">add</span><span>(</span><span class="number-literal">4</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">heap3</span><span> = </span><span class="identifier">heap1</span><span>.</span><span class="identifier">merge</span><span>(</span><span class="identifier">heap2</span><span>) </span><span class="comment">// this typechecks
</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">heap4</span><span> = </span><span class="identifier">maxHeaps</span><span>.</span><span class="identifier">empty</span><span>.</span><span class="identifier">add</span><span>(</span><span class="number-literal">6</span><span>).</span><span class="identifier">add</span><span>(</span><span class="number-literal">4</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">heap5</span><span> = </span><span class="identifier">heap1</span><span>.</span><span class="identifier">merge</span><span>(</span><span class="identifier">heap4</span><span>) </span><span class="comment">// !!!type error!!!</span></code></pre>
    <p>Notice that <code>heap1</code>, <code>heap2</code>, and <code>heap3</code> have type <code>minHeaps.Heap</code> but <code>heap4</code> has type <code>maxHeaps.Heap</code>.
    According to Scala&#39;s notion of <em>path-dependent types</em>, these types are incompatible so attempting to merge <code>heap1</code> and <code>heap4</code> causes a type error, as desired.</p>
    
    <h2 id="a-question" class="section"><a class="anchor-link" href="#a-question"><code class="fas fa-link fa-sm"></code></a>A question</h2>
    <p>Clearly, if I create two factories with incompatible element types, then a heap from one factory should not be mergeable with a heap from the other factory.
    Similarly, if I create two factories with the same element type but incompatible orderings, then again a heap from one factory should not be mergeable with a heap from the other factory.</p>
    <p>But what if I create two separate factories with the same element type and the same ordering?
    Should a heap created from one of these factories be mergeable with a heap created from the other factory?
    It&#39;s not clear.
    If this duplication of factories was deliberate, then the answer is probably “no”.
    This often happens with units of measure.
    For example, maybe one of the factories is using integers to represent inches and the other is using integers to represent grams.
    Even if the factories are using the same ordering, we probably don&#39;t want to merge a heap of inches with a heap of grams!</p>
    <p>On the other hand, the duplication of factories could be accidental, perhaps the result of two chunks of code being written separately and then brought together later.
    In that case, we might very well want to be able to merge a heap from one factory with a heap from another accidentally-separate-but-equivalent factory.</p>
    <p>Regardless of where you come down on what <em>should</em> happen, what <em>will</em> happen in the above design is that attempting to merge heaps from distinct factories will cause a type error, even if the factories were made for the same element type and ordering.</p>
    
    <h2 id="problem-4-usability-in-the-simple-case" class="section"><a class="anchor-link" href="#problem-4-usability-in-the-simple-case"><code class="fas fa-link fa-sm"></code></a>Problem 4: Usability in the simple case</h2>
    <p>Most applications of priority queues do not need the <code>merge</code> method.
    Trying to make <code>merge</code> typesafe has made the API more complicated and harder to use because of the need to instantiate a factory before creating actual heaps.
    Can we hide these complications from a user until and unless they actually need to use <code>merge</code>? Yes.</p>
    <p>I&#39;ll re-introduce the interface without <code>merge</code>, but now called <code>SHeap</code> for “Simple Heap”:</p>
    <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">SHeap</span><span>[</span><span class="type-name">Elem</span><span>] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">isEmpty</span><span>: </span><span class="type-name">Boolean</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">add</span><span>(</span><span class="identifier">elem</span><span>: </span><span class="type-name">Elem</span><span>): </span><span class="type-name">SHeap</span><span>[</span><span class="type-name">Elem</span><span>]
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">first</span><span>: </span><span class="type-name">Elem</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">rest</span><span>: </span><span class="type-name">SHeap</span><span>[</span><span class="type-name">Elem</span><span>]
}</span></code></pre>
    <p>Then <code>MHeap</code> should be a subtype of <code>SHeap</code>:</p>
    <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">MHeap</span><span>[</span><span class="type-name">Elem</span><span>, </span><span class="type-name">Heap</span><span> &lt;: </span><span class="type-name">SHeap</span><span>[</span><span class="type-name">Elem</span><span>]] </span><span class="keyword">extends</span><span> </span><span class="type-name">SHeap</span><span>[</span><span class="type-name">Elem</span><span>] {
  </span><span class="comment">// inherits isEmpty and first from SHeap[Elem]
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">add</span><span>(</span><span class="identifier">elem</span><span>: </span><span class="type-name">Elem</span><span>): </span><span class="type-name">Heap</span><span> </span><span class="comment">// more specific return type
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">rest</span><span>: </span><span class="type-name">Heap</span><span> </span><span class="comment">// more specific return type
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">merge</span><span>(</span><span class="identifier">other</span><span>: </span><span class="type-name">Heap</span><span>): </span><span class="type-name">Heap</span><span>
}</span></code></pre>
    <p>The <code>HeapFactory</code> definition is unchanged:</p>
    <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">HeapFactory</span><span> {
  </span><span class="keyword">type</span><span> </span><span class="type-name">Elem</span><span>
  </span><span class="keyword">type</span><span> </span><span class="type-name">Heap</span><span> &lt;: </span><span class="type-name">MHeap</span><span>[</span><span class="type-name">Elem</span><span>,</span><span class="type-name">Heap</span><span>]

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">empty</span><span>: </span><span class="type-name">Heap</span><span>
  </span><span class="comment">// plus other factory methods
</span><span>}</span></code></pre>
    <p>The last part is that the companion object should supply simple factory methods in terms of <code>SHeap</code>:</p>
    <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">LeftistHeap</span><span> { </span><span class="comment">// companion object
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">empty</span><span>[</span><span class="type-name">E</span><span>](</span><span class="keyword">implicit</span><span> </span><span class="identifier">ord</span><span>: </span><span class="type-name">Ordering</span><span>[</span><span class="type-name">E</span><span>]): </span><span class="type-name">SHeap</span><span>[</span><span class="type-name">E</span><span>] = ???
  </span><span class="comment">// plus other ordinary factory methods, similar to other Scala collections
</span><span>
  </span><span class="comment">// the big bad
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">factory</span><span>[</span><span class="type-name">E</span><span>](</span><span class="keyword">implicit</span><span> </span><span class="identifier">ord</span><span>: </span><span class="type-name">Ordering</span><span>[</span><span class="type-name">E</span><span>]): </span><span class="type-name">HeapFactory</span><span> { </span><span class="keyword">type</span><span> </span><span class="type-name">Elem</span><span> = </span><span class="type-name">E</span><span> } = ???
}</span></code></pre>
    <p>Now the user can proceed in blissful ignorance of <code>factory</code> or <code>MHeap</code>, treating this essentially just like any other Scala collection, until they need <code>merge</code>.
    Of course, <code>empty</code> will probably be defined as</p>
    <pre><code class="nohighlight"><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">empty</span><span>[</span><span class="type-name">E</span><span>](</span><span class="keyword">implicit</span><span> </span><span class="identifier">ord</span><span>: </span><span class="type-name">Ordering</span><span>[</span><span class="type-name">E</span><span>]): </span><span class="type-name">SHeap</span><span>[</span><span class="type-name">E</span><span>] = </span><span class="identifier">factory</span><span>[</span><span class="type-name">E</span><span>](</span><span class="identifier">ord</span><span>).</span><span class="identifier">empty</span></code></pre>
    <p>(and similarly for the other ordinary factory methods), but the user doesn&#39;t need to know that.</p>
    
    <h2 id="problem-5-min-vs-max" class="section"><a class="anchor-link" href="#problem-5-min-vs-max"><code class="fas fa-link fa-sm"></code></a>Problem 5: <code>min</code> vs <code>max</code></h2>
    <p>Should a heap favor smaller elements or bigger elements?
    There&#39;s no obvious answer&amp;mdash;applications abound for both.
    Therefore, an interface should easily support both flavors.
    Right now, the ordering parameter allows us to say</p>
    <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">minHeaps</span><span> = </span><span class="type-name">LeftistHeap</span><span>.</span><span class="identifier">factory</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="type-name">Ordering</span><span>.</span><span class="type-name">Int</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">maxHeaps</span><span> = </span><span class="type-name">LeftistHeap</span><span>.</span><span class="identifier">factory</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="type-name">Ordering</span><span>.</span><span class="type-name">Int</span><span>.</span><span class="identifier">reverse</span><span>)</span></code></pre>
    <p>But how did I know that <code>Ordering.Int</code> was the right ordering for min-heaps and <code>Ordering.Int.reverse</code> was the right ordering for max-heaps?
    The opposite could just as easily have been true.
    Sure, this detail would probably be documented in the API, but it was fundamentally a flip-a-coin arbitrary decision.
    And arbitrary decisions with no logic favoring one choice over the other are the hardest to remember.</p>
    <p>In an easier-to-use interface, the user might write:</p>
    <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">minHeaps</span><span> = </span><span class="type-name">LeftistHeap</span><span>.</span><span class="identifier">minFactory</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="type-name">Ordering</span><span>.</span><span class="type-name">Int</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">maxHeaps</span><span> = </span><span class="type-name">LeftistHeap</span><span>.</span><span class="identifier">maxFactory</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="type-name">Ordering</span><span>.</span><span class="type-name">Int</span><span>)</span></code></pre>
    <p>Now, the user doesn&#39;t need to worry whether to use <code>Ordering.Int</code> or <code>Ordering.Int.reverse</code>.
    Instead, if they want min-oriented heaps, they call <code>minFactory(Ordering.Int)</code> and if they want max-oriented heaps, they call <code>maxFactory(Ordering.Int)</code>.
    In fact, it&#39;s even better than that.
    The whole point of implicit parameters is that you usually don&#39;t need to write them down explicitly.
    In reality, the user would probably only write:</p>
    <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">minHeaps</span><span> = </span><span class="type-name">LeftistHeap</span><span>.</span><span class="identifier">minFactory</span><span>[</span><span class="type-name">Int</span><span>]
</span><span class="keyword">val</span><span> </span><span class="identifier">maxHeaps</span><span> = </span><span class="type-name">LeftistHeap</span><span>.</span><span class="identifier">maxFactory</span><span>[</span><span class="type-name">Int</span><span>]</span></code></pre>
    <p>Actually, in the current version of scads, this is now</p>
    <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">minHeaps</span><span> = </span><span class="type-name">LeftistHeap</span><span>.</span><span class="type-name">Min</span><span>.</span><span class="identifier">factory</span><span>[</span><span class="type-name">Int</span><span>]
</span><span class="keyword">val</span><span> </span><span class="identifier">maxHeaps</span><span> = </span><span class="type-name">LeftistHeap</span><span>.</span><span class="type-name">Max</span><span>.</span><span class="identifier">factory</span><span>[</span><span class="type-name">Int</span><span>]</span></code></pre>
    <p>where <code>LeftistHeap.Min</code> and <code>LeftistHeap.Max</code> both support other simpler methods for creating <code>SHeap</code>s for users who don&#39;t need <code>merge</code>.
    For example, a user could write:</p>
    <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">h1</span><span> = </span><span class="type-name">LeftistHeap</span><span>.</span><span class="type-name">Min</span><span>.</span><span class="identifier">empty</span><span>[</span><span class="type-name">Int</span><span>] </span><span class="comment">// an empty min-heap of integers
</span><span class="keyword">val</span><span> </span><span class="identifier">h2</span><span> = </span><span class="type-name">LeftistHeap</span><span>.</span><span class="type-name">Max</span><span>(</span><span class="number-literal">1</span><span>,</span><span class="number-literal">2</span><span>,</span><span class="number-literal">3</span><span>) </span><span class="comment">// a max-heap containing 1, 2, and 3</span></code></pre>
    <p>Of course, there&#39;s lots more needed to flesh the whole design out into an industrial-strength API, and even more to integrate it with the current Scala collections.
    I&#39;ll continue to work on this, and I welcome discussion on these issues.</p>
  </div>
</div>
<div class="bulma-section bulma-container bulma-is-max-desktop">
  <div class="bulma-columns">
    
    <div class="bulma-column">
      <article class="bulma-media">
  
  <figure class="bulma-media-left">
    <p class="bulma-image bulma-is-64x64">
      <img class="bulma-is-rounded" src="https://github.com/chrisokasaki.png" />
    </p>
  </figure>
  
  <div class="bulma-media-content">
    <div class="bulma-content">
      <p>
        <strong>Chris Okasaki</strong> 
        
        
        
        
      </p>
    </div>
    <nav class="bulma-level bulma-is-align-items-start">
      <div class="bulma-level-left bulma-is-flex-direction-row">
        
        
        
        <a class="bulma-level-item" href="http://github.com/chrisokasaki">
          <span class="bulma-icon bulma-is-small"><i class="fab fa-github"></i></span>
        </a>
        
        
        
        
      </div>
    </nav>
  </div>
</article>

    </div>
    
  </div>
</div>


  </main>
  <footer class="bulma-footer">
  <div class="bulma-columns">
    <div class="bulma-column bulma-is-half">
      Copyright 2026 Typelevel Foundation and <a href="https://github.com/typelevel/typelevel.github.com/graphs/contributors">contributors</a>.
      Licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> unless <a href="../colophon.html#license">noted otherwise</a>.
    </div>
    <div class="bulma-column">
      <ul>
        <li><a href="../projects/">Project Index</a></li>
        <li><a href="../community/meetups.html">Meetup Calendar</a></li>
        <li><a href="../foundation/people.html">Leadership</a></li>
      </ul>
    </div>
    <div class="bulma-column">
      <ul>
        <li><a href="../code-of-conduct/">Code of Conduct</a></li>
        <li><a href="../security.html">Security Policy</a></li>
        <li><a href="../colophon.html">Colophon</a></li>
      </ul>
    </div>
  </div>
  <div class="bulma-has-text-centered">
    <div>Find us on ...</div>
    <div>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://github.com/typelevel">
        <i class="fab fa-github fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://discord.gg/typelevel-632277896739946517">
        <i class="fab fa-discord fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://bsky.app/profile/typelevel.org">
        <i class="fab fa-bluesky fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://fosstodon.org/@typelevel">
        <i class="fab fa-mastodon fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://www.youtube.com/@typelevel">
        <i class="fab fa-youtube fa-2x"></i>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current"
        href="https://linkedin.com/company/typelevel-foundation">
        <i class="fab fa-linkedin fa-2x"></i>
      </a>
    </div>
  </div>
</footer>

</body>

</html>

